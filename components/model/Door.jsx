"use client"

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.13 /home/TA/resource/Door.glb --transform --shadows --keepgroups 
Files: /home/TA/resource/Door.glb [14.32MB] > Door-transformed.glb [1.21MB] (92%)
*/

import { useRef } from 'react'
import { useGLTF } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import { RigidBody, quat, useRapier, vec3 } from '@react-three/rapier'
import { Ray } from '@dimforge/rapier3d-compat'
import { Quaternion, Euler } from 'three'

export function Door(props) {
  // Refs
  const doorLeft = useRef(null)
  const doorRight = useRef(null)

  const { nodes, materials } = useGLTF('models/Door-transformed.glb')

  const { world } = useRapier()
  useFrame(() => {
    let [doorLeftPos, doorRightPos] = [vec3(doorLeft.current.translation()), vec3(doorRight.current.translation())]
    doorLeftPos.x += 0.2; doorRightPos.x -= 0.2
    const [doorLeftRot, doorRightRot] = [quat(doorLeft.current.rotation()), quat(doorRight.current.rotation())]

    // Ray in & out
    const rayIn = new Ray(vec3({ ...doorLeftPos, y: doorLeftPos.y += 0.1 }), { x: 0, y: 0, z: 1 })
    const rayOut = new Ray(vec3({ ...doorRightPos, y: doorRightPos.y += 0.1 }), { x: 0, y: 0, z: -1 })

    // Intersect in & out
    const intersectIn = world.castRay(rayIn, 1, false, undefined, undefined, undefined, doorLeft.current)
    const intersectOut = world.castRay(rayOut, 1, false, undefined, undefined, undefined, doorRight.current)

    if (intersectIn || intersectOut) {
      doorLeftRot.slerp(new Quaternion().setFromEuler(new Euler(0, Math.PI / 2, 0, "XYZ"), true), 0.6)
      doorLeft.current.setRotation(doorLeftRot)
      doorRightRot.slerp(new Quaternion().setFromEuler(new Euler(0, Math.PI / 2, 0, "XYZ"), true), 0.6)
      doorRight.current.setRotation(doorRightRot)
    } else {
      doorLeftRot.slerp(new Quaternion().setFromEuler(new Euler(0, 0, 0, "XYZ"), true), 0.6)
      doorLeft.current.setRotation(doorLeftRot)
      doorRightRot.slerp(new Quaternion().setFromEuler(new Euler(0, Math.PI, 0, "XYZ"), true), 0.6)
      doorRight.current.setRotation(doorRightRot)
    }
  }, 3)
  return (
    <group {...props} dispose={null}>
      <RigidBody ref={doorLeft} colliders='cuboid' type='fixed' position-x={-0.25}>
        <group position-x={0.25}>
          <mesh castShadow receiveShadow geometry={nodes.Cylinder001.geometry} material={materials.Handle_Metal} position={[-0.021, 0.381, 0.002]} rotation={[Math.PI / 2, 0, 0]} />
          <mesh castShadow receiveShadow geometry={nodes['Door-light'].geometry} material={materials['Afromosia Fine Wood']} />
          <mesh castShadow receiveShadow geometry={nodes['Glass-door-light'].geometry} material={materials.Glass} position={[-0.078, 0.486, 0]} />
        </group>
      </RigidBody>
      <RigidBody ref={doorRight} colliders='cuboid' type='fixed' rotation-y={Math.PI} position-x={0.25}>
        <group position-x={0.25}>
          <mesh castShadow receiveShadow geometry={nodes.Cylinder001.geometry} material={materials.Handle_Metal} position={[-0.021, 0.381, 0.002]} rotation={[Math.PI / 2, 0, 0]} />
          <mesh castShadow receiveShadow geometry={nodes['Door-light'].geometry} material={materials['Afromosia Fine Wood']} />
          <mesh castShadow receiveShadow geometry={nodes['Glass-door-light'].geometry} material={materials.Glass} position={[-0.078, 0.486, 0]} />
        </group>
      </RigidBody>
    </group>
  )
}

useGLTF.preload('models/Door-transformed.glb')